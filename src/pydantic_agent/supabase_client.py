"""
Supabase Vector Database Client for Pydantic AI Agent.

This module provides a client for interacting with Supabase as a vector database,
enabling semantic search and knowledge retrieval.
"""

import os
import json
from typing import Dict, List, Any, Optional, Union
import asyncio
from supabase import Client as SupabaseClient, create_client


class SupabaseVectorClient:
    """
    Client for interacting with Supabase as a vector database.
    
    This client provides methods for semantic search and document management
    using Supabase's vector capabilities (pgvector).
    """
    
    def __init__(self, client: SupabaseClient):
        """
        Initialize the Supabase Vector Client.
        
        Args:
            client: An initialized Supabase client
        """
        self.client = client
    
    @classmethod
    def from_env(cls) -> "SupabaseVectorClient":
        """
        Create a Supabase Vector Client from environment variables.
        
        Returns:
            A new SupabaseVectorClient instance
            
        Raises:
            ValueError: If required environment variables are missing
        """
        supabase_url = os.getenv("SUPABASE_URL")
        supabase_key = os.getenv("SUPABASE_KEY")
        
        if not supabase_url or not supabase_key:
            raise ValueError("SUPABASE_URL and SUPABASE_KEY environment variables must be set")
        
        client = create_client(supabase_url, supabase_key)
        return cls(client)
    
    async def add_documents(
        self,
        table_name: str,
        documents: List[str],
        metadatas: Optional[List[Dict[str, Any]]] = None,
        batch_size: int = 100
    ) -> List[Dict[str, Any]]:
        """
        Add documents to a Supabase table with vector embeddings.
        
        This method will:
        1. Batch documents for efficient insertion
        2. Generate embeddings using a server-side function
        3. Insert documents with their metadata and embeddings
        
        Args:
            table_name: Name of the table to insert into
            documents: List of document texts
            metadatas: Optional list of metadata dictionaries for each document
            batch_size: Size of batches for adding documents
            
        Returns:
            List of insertion results
        """
        # Create default metadata if none provided
        if metadatas is None:
            metadatas = [{}] * len(documents)
        
        # Initialize results
        results = []
        
        # Process documents in batches
        for i in range(0, len(documents), batch_size):
            batch_documents = documents[i:i+batch_size]
            batch_metadatas = metadatas[i:i+batch_size]
            
            # Prepare data for insertion
            data = []
            for j, (doc, meta) in enumerate(zip(batch_documents, batch_metadatas)):
                # Convert metadata to JSON string if needed
                if isinstance(meta, dict):
                    meta_json = json.dumps(meta)
                else:
                    meta_json = meta
                
                data.append({
                    "content": doc,
                    "metadata": meta_json,
                    # Embedding will be generated by a database trigger or Edge Function
                })
            
            # Insert the batch
            response = self.client.table(table_name).insert(data).execute()
            
            # Check for errors
            if hasattr(response, 'error') and response.error:
                raise Exception(f"Error adding documents to Supabase: {response.error}")
            
            # Add results
            if hasattr(response, 'data'):
                results.extend(response.data)
        
        return results
    
    async def search_documents(
        self,
        table_name: str,
        query_text: str,
        limit: int = 5,
        filter_metadata: Optional[Dict[str, Any]] = None
    ) -> List[Dict[str, Any]]:
        """
        Search for documents in Supabase using vector similarity.
        
        This method will:
        1. Generate an embedding for the query text
        2. Perform a vector similarity search against the database
        3. Return the most relevant documents
        
        Args:
            table_name: Name of the table to search in
            query_text: The search query
            limit: Maximum number of results to return
            filter_metadata: Optional metadata filters to apply
            
        Returns:
            List of documents with their content, metadata, and relevance scores
        """
        # Call a Supabase Function or RPC to perform the vector search
        # This assumes you have set up a Supabase Function or RPC for vector search
        
        # Build RPC call parameters
        params = {
            'query_text': query_text,
            'match_count': limit,
            'table_name': table_name
        }
        
        if filter_metadata:
            params['filter_metadata'] = json.dumps(filter_metadata)
        
        # Call the RPC function
        try:
            response = self.client.rpc('search_documents', params).execute()
            
            # Check for errors
            if hasattr(response, 'error') and response.error:
                raise Exception(f"Error searching documents in Supabase: {response.error}")
            
            # Process results
            results = []
            if hasattr(response, 'data') and response.data:
                for item in response.data:
                    # Parse metadata from JSON if needed
                    metadata = item.get('metadata', '{}')
                    if isinstance(metadata, str):
                        try:
                            metadata = json.loads(metadata)
                        except json.JSONDecodeError:
                            metadata = {}
                    
                    # Build result object
                    result = {
                        'id': item.get('id'),
                        'content': item.get('content'),
                        'metadata': metadata,
                        'relevance': item.get('similarity', 0.0)
                    }
                    
                    results.append(result)
            
            return results
        
        except Exception as e:
            print(f"Error in search_documents: {str(e)}")
            return []
    
    async def delete_document(self, table_name: str, document_id: str) -> bool:
        """
        Delete a document from Supabase.
        
        Args:
            table_name: Name of the table
            document_id: ID of the document to delete
            
        Returns:
            Success status
        """
        try:
            response = self.client.table(table_name).delete().eq('id', document_id).execute()
            
            # Check for errors
            if hasattr(response, 'error') and response.error:
                raise Exception(f"Error deleting document in Supabase: {response.error}")
            
            return True
        
        except Exception as e:
            print(f"Error in delete_document: {str(e)}")
            return False
    
    async def update_document(
        self,
        table_name: str,
        document_id: str,
        content: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Update a document in Supabase.
        
        Args:
            table_name: Name of the table
            document_id: ID of the document to update
            content: New content for the document (None to keep existing)
            metadata: New metadata for the document (None to keep existing)
            
        Returns:
            Updated document data
        """
        # Prepare update data
        update_data = {}
        
        if content is not None:
            update_data['content'] = content
        
        if metadata is not None:
            update_data['metadata'] = json.dumps(metadata)
        
        if not update_data:
            return {'id': document_id, 'message': 'No updates provided'}
        
        try:
            # Update the document
            response = self.client.table(table_name).update(update_data).eq('id', document_id).execute()
            
            # Check for errors
            if hasattr(response, 'error') and response.error:
                raise Exception(f"Error updating document in Supabase: {response.error}")
            
            # Return updated document data
            if hasattr(response, 'data') and response.data:
                return response.data[0]
            
            return {'id': document_id, 'message': 'Update successful but no data returned'}
        
        except Exception as e:
            print(f"Error in update_document: {str(e)}")
            return {'id': document_id, 'error': str(e)}
